[目录](./)
# 【英翻】Node.js突然流行

## 前言
网上既有的翻译应该挺多了，这里只想练习一下自己的英语，嗯。

## 译文

如果你去年经常关注技术新闻的话，应该至少会有这么一两次机会听到node.js 这个词。为了搞明白到底发生了什么，估计你会问：“nodejs是什么？”然后就会有人（或者 Google）会回答你：“那是用Javascript来开发网络服务的”。如果不理解，你或许会接着问：“为什么我们要去用它？”然后有很大的机会，回答会告诉你：非阻塞（non-blocking）、事件驱动（event-driven）IO，可以让长轮询（long polling）或者 comet-based<sup id="a0"><a href="#f0">注0</a></sup>来实现高并发。

不管是决定什么时候停下提问，我都不会责怪于你。我会尝试着用简单易懂的人话来解释什么是 Nodejs 以及你为什么会需要选择它。  
浏览器发送请求（request）给网站的方式从来就没有变过。网站的服务会接收这些请求，查找被请求的文件，或者回去搜索数据库，最后返回一个响应（response)给浏览器。在像apache那样的传统的web服务器上，所有的请求都会在服务器端生成一个新的系统进程来处理。

然后出现了ajax，替代了每次都要提交修改整个网页的请求方式，我们只需要请求我们所要的那部分信息就可以了。OK，那确实是个进步。

但现在让我们去构建一个类似 FriendFeed的网站，所有用户都在实时刷信息。解决方法只有让每个用户实时保持一个可用的链接。最简单的实现方式就是使用长轮询。  
长轮询其实让HTTP看起来像是持续链接：不管页面是不是有需要，只要加载就向服务器发送ajax请求。但是不像普通的ajax请求，服务器并不会马上响应，而是一直等待在那里，直到服务器认为该响应点什么东西给浏览器的时候。比如你的朋友新发了一条朋友圈，服务器就会把这些推送给浏览器，然后告诉浏览器可以更新显示了。当浏览器接受到这些信息，就会发送一个新的请求到服务器上，并再次等待着服务器的回信。

让我们来想像一下这对apache之类的传统服务器意味着要为每个新用户建立一个链接，并保持畅通。每个连接都需要一个进程，每个进程的大部分时间要么是干等着（消耗内存），要么等待数据库完成查询。这意味着你很难提升链接数，除非让你的网站卡死，要么耗尽服务器的资源。<sup id="a1"><a href="#f1">注1</a></sup>

所以解决方案呢？这里必须复习一下之前提到过的两个转有名词：非阻塞和事件驱动。不管其他情况，仅在这里这些术语并不比你想像的更可怕。一个非阻塞服务器就是一直在做循环（loop）：一遍又一遍的循环。当有请求的时候，循环捕获住这个请求，并将他交给一个单独的进程（比如数据库查询），并设置一个回调（callback），然后就继续循环等待下一个请求。服务器并不占着内存傻等等数据库的返回。  
如果数据库的查询有结果了，没问题，我们用同样的方法来处理：把处理结果丢还给客户端（client），然后继续循环。从理论上来说，这会让数据库查询数没有任何等待限制，或者客户端也一样。因为你的服务器并不花时间去等待它们。你是让他们自己管自己，以及要说一下什么是事件驱动：服务器只会在有事情发生的时候才会做出反应。可以是一个请求，可以是文件加载完毕，也可以是数据库查询结果，不一而定。

FreiendFeed现在使用的是一个用 Python 写的，名叫Tornado非阻塞框架来解决这个问题。Nginx也是这么干的<sup id="a2"><a href="#f2">注2</a></sup>。nodejs，它手中的王牌就是：使用javascript，并运行在GoogleV8那疯狂的引擎上。它从来不用担心一个请求是否会对另一段代码造成循环阻塞。因为javascript天生就是事件驱动的。回想一下：当你在浏览器中写 javascript 的时候，你总是在处理各种事件句柄（handle）和回调函数。javascript 就是被这么设计的。

nodejs 也还不完善，所以如果想要用它开发一个应用程序，那就得自己写很多底层（low level）代码。但随着下一代浏览器开始使用WebSocket（完全不需要长轮询），这种类型的web开发技术也会越来越重要。我希望我能让你的脑子里对这些东西有了一个概念，并准备去尝试它一下。

## 译注

* <span id="f0"><a href="#a0">注0</a></span> comet 我查不到怎么用中文表达。简单解释，就是一种推送技术，具体可以参考维基百科：（英）Comet\_(programming)，（中）Comet\_(web技术)。
* <span id="f1"><a href="#a1">注1</a></span> 这里的原文是“without grinding to a near halt and using up all your resources.”，前半句“without grinding to a near halt”有些没理解，所以这里暂时望文生义地翻译成“让你的网站卡死”。
* <span id="f2"><a href="#a2">注2</a></span> 感觉原文里的的这句“ The nginx web server also behaves in this way. ”有些脱离上下文，怎么就突然冒出个 nginx 来。不知道原作者写这句话的意思是什么，可能是想说 nginx 也是事件驱动的。但只是我的猜想，所以仅供参考。nginx 和 apache的对比，可以参考segmentfault 上的这篇文章：[Apache—MPMs && Nginx事件驱动](https://segmentfault.com/a/1190000007875157)。

## 原文

[https://www.sitepoint.com/node-js-is-the-new-black/](https://www.sitepoint.com/node-js-is-the-new-black/)